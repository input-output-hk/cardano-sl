-- | Generation of genesis data for testnet.

module Pos.Core.Genesis.Testnet
       ( GeneratedGenesisData (..)
       , generateFakeAvvmSeed
       , generateFakeAvvm

       , generateSecrets
       , generateSecretsAndAddress

       , generateFakeAvvmGenesis
       , generateTestnetData

       , generateTestnetOrMainnetData
       ) where

import           Universum

import           Crypto.Random              (getRandomBytes)
import qualified Data.HashMap.Strict        as HM
import qualified Data.Map.Strict            as Map
import           Formatting                 (sformat, shown, (%))
import           Serokell.Util.Text         (listJson)
import           Serokell.Util.Verify       (VerificationRes (..), formatAllErrors,
                                             verifyGeneric)
import           System.Wlog                (WithLogger, logInfo)

import           Pos.Binary.Class           (asBinary)
import           Pos.Core.Address           (Address, IsBootstrapEraAddr (..),
                                             addressDetailedF, addressHash,
                                             deriveLvl2KeyPair, makePubKeyAddressBoot,
                                             makeRedeemAddress)
import           Pos.Core.Coin              (coinPortionToDouble, mkCoin,
                                             unsafeIntegerToCoin)
import qualified Pos.Core.Genesis.Constants as Const
import           Pos.Core.Genesis.Types     (AddrDistribution, BalanceDistribution (..),
                                             FakeAvvmOptions (..),
                                             GenesisInitializer (..),
                                             GenesisWStakeholders (..),
                                             TestnetBalanceOptions (..),
                                             TestnetDistribution (..))
import           Pos.Core.Vss               (VssCertificate, VssCertificatesMap,
                                             mkVssCertificate)
import           Pos.Crypto                 (EncryptedSecretKey, RedeemPublicKey,
                                             SecretKey, VssKeyPair, emptyPassphrase,
                                             keyGen, randomNumberInRange,
                                             redeemDeterministicKeyGen, runGlobalRandom,
                                             safeKeyGen, setGlobalRandomSeed, toPublic,
                                             toVssPublicKey, vssKeyGen)

-- | Data generated by @genTestnetOrMainnetData@ using genesis-spec.
data GeneratedGenesisData = GeneratedGenesisData
    { ggdNonAvvmDistr     :: ![AddrDistribution]
    -- ^ Address distribution for non avvm addresses
    , ggdBootStakeholders :: !GenesisWStakeholders
    -- ^ Set of boot stakeholders (richmen addresses or custom addresses)
    , ggdGtData           :: !VssCertificatesMap
    -- ^ Genesis vss data (vss certs of richmen)
    , ggdSecretKeys       :: !(Maybe [(SecretKey, EncryptedSecretKey, VssKeyPair)])
    -- ^ Secret keys for non avvm addresses
    }

generateTestnetOrMainnetData
    :: (MonadIO m, MonadThrow m, WithLogger m)
    => GenesisInitializer
    -> m GeneratedGenesisData
generateTestnetOrMainnetData TestnetInitializer{..} = do
    liftIO (setGlobalRandomSeed tiSeed)
    fakeAvvmDistr <- generateFakeAvvmGenesis tiFakeAvvmBalance
    testnetGenData <- generateTestnetData tiTestBalance tiDistribution
    let testnetDistr = ggdNonAvvmDistr testnetGenData
    pure $ testnetGenData {ggdNonAvvmDistr = testnetDistr ++ fakeAvvmDistr}
generateTestnetOrMainnetData MainnetInitializer{..} =
    pure $ GeneratedGenesisData [] miBootStakeholders miVssCerts Nothing

-- | Generates keys and vss certs for testnet data.
generateTestnetData
    :: (MonadIO m, MonadThrow m, WithLogger m)
    => TestnetBalanceOptions
    -> TestnetDistribution
    -> m GeneratedGenesisData
generateTestnetData tso@TestnetBalanceOptions{..} distrSpec = do
    (richmenList, poorsList) <-
        (,) <$> replicateM (fromIntegral tboRichmen) (generateSecretsAndAddress Nothing)
            <*> replicateM (fromIntegral tboPoors)   (generateSecretsAndAddress Nothing)

    let skVssCerts = map (\(sk, _, _, vc, _) -> (sk, vc)) $ richmenList ++ poorsList
    let richSkVssCerts = take (fromIntegral tboRichmen) skVssCerts
    let secretKeys = map (\(sk, hdwSk, vssSk, _, _) -> (sk, hdwSk, vssSk)) $ richmenList ++ poorsList

    let distr = genTestnetDistribution tso
        genesisAddrs = map (makePubKeyAddressBoot . toPublic . fst) skVssCerts
                    <> map (view _5) poorsList
        genesisAddrDistr = [(genesisAddrs, distr)]

    case distr of
        RichPoorBalances {} -> pass
        _                   -> error "Impossible type of generated testnet balance"
    let toStakeholders = Map.fromList . map ((,1) . addressHash . toPublic . fst)
    let toVss = HM.fromList . map (_1 %~ addressHash . toPublic)

    let (bootStakeholders, gtData) =
            case distrSpec of
                TestnetRichmenStakeDistr    -> (toStakeholders richSkVssCerts, toVss richSkVssCerts)
                TestnetCustomStakeDistr{..} -> (getGenesisWStakeholders tcsdBootStakeholders, tcsdVssCerts)

    logInfo $ sformat ("testnet genesis created successfully. "
                      %"First 10 addresses: "%listJson%" distr: "%shown)
              (map (sformat addressDetailedF) $ take 10 genesisAddrs)
              distr
    pure $ GeneratedGenesisData
        { ggdNonAvvmDistr = genesisAddrDistr
        , ggdBootStakeholders = GenesisWStakeholders bootStakeholders
        , ggdGtData = gtData
        , ggdSecretKeys = Just secretKeys
        }

generateFakeAvvmGenesis
    :: (MonadIO m, WithLogger m)
    => FakeAvvmOptions -> m [AddrDistribution]
generateFakeAvvmGenesis FakeAvvmOptions{..} = do
    fakeAvvmPubkeys <- replicateM (fromIntegral faoCount) generateFakeAvvm

    let gcdAddresses = map makeRedeemAddress fakeAvvmPubkeys
        gcdDistribution = CustomBalances $
            replicate (length gcdAddresses)
                      (mkCoin $ fromIntegral faoOneBalance)

    pure [(gcdAddresses, gcdDistribution)]

----------------------------------------------------------------------------
-- Helpers
----------------------------------------------------------------------------

generateSecretsAndAddress
    :: (MonadIO m, MonadThrow m, WithLogger m)
    => Maybe (SecretKey, EncryptedSecretKey)  -- ^ plain key & hd wallet root key
    -> m (SecretKey, EncryptedSecretKey, VssKeyPair, VssCertificate, Address)
    -- ^ secret key, vss key pair, vss certificate,
    -- hd wallet account address with bootstrap era distribution
generateSecretsAndAddress mbSk = do
    (sk, hdwSk, vss) <- generateSecrets mbSk

    expiry <- liftIO $ runGlobalRandom $
        fromInteger <$>
        randomNumberInRange (Const.vssMinTTL - 1) (Const.vssMaxTTL - 1)
    let vssPk = asBinary $ toVssPublicKey vss
        vssCert = mkVssCertificate sk vssPk expiry
        -- This address is used only to create genesis data. We don't
        -- put it into a keyfile.
        hdwAccountPk =
            fst $ fromMaybe (error "generateKeyfile: pass mismatch") $
            deriveLvl2KeyPair (IsBootstrapEraAddr True) emptyPassphrase hdwSk
                Const.accountGenesisIndex Const.wAddressGenesisIndex
    pure (sk, hdwSk, vss, vssCert, hdwAccountPk)

generateFakeAvvm :: MonadIO m => m RedeemPublicKey
generateFakeAvvm = do
    seed <- generateFakeAvvmSeed
    let (pk, _) = fromMaybe
            (error "Impossible - seed is not 32 bytes long") $
            redeemDeterministicKeyGen seed
    pure pk

generateSecrets
    :: (MonadIO m, MonadThrow m)
    => Maybe (SecretKey, EncryptedSecretKey)
    -> m (SecretKey, EncryptedSecretKey, VssKeyPair)
generateSecrets mbSk = do
      -- ^ plain key & hd wallet root key
    (sk, hdwSk) <- case mbSk of
        Just x  -> return x
        Nothing -> liftIO $ runGlobalRandom $
            (,) <$> (snd <$> keyGen)
                <*> (snd <$> safeKeyGen emptyPassphrase)
    vss <- liftIO $ runGlobalRandom vssKeyGen
    pure (sk, hdwSk, vss)

generateFakeAvvmSeed :: MonadIO m => m ByteString
generateFakeAvvmSeed = liftIO $ runGlobalRandom $ getRandomBytes 32

-- | Generates balance distribution for testnet.
genTestnetDistribution :: TestnetBalanceOptions -> BalanceDistribution
genTestnetDistribution TestnetBalanceOptions{..} =
    checkConsistency $ RichPoorBalances {..}
  where
    richs = fromIntegral tboRichmen
    poors = fromIntegral tboPoors * 2  -- for plain and hd wallet keys
    testBalance = fromIntegral tboTotalBalance

    -- Calculate actual balances
    desiredRichBalance = getShare tboRichmenShare testBalance
    oneRichmanBalance = desiredRichBalance `div` richs +
        if desiredRichBalance `mod` richs > 0 then 1 else 0
    realRichBalance = oneRichmanBalance * richs
    poorsBalance = testBalance - realRichBalance
    onePoorBalance = if poors == 0 then 0 else poorsBalance `div` poors
    realPoorBalance = onePoorBalance * poors

    mpcBalance = getShare (coinPortionToDouble Const.genesisMpcThd) testBalance

    sdRichmen = fromInteger richs
    sdRichBalance = unsafeIntegerToCoin oneRichmanBalance
    sdPoor = fromInteger poors
    sdPoorBalance = unsafeIntegerToCoin onePoorBalance

    -- Consistency checks
    everythingIsConsistent :: [(Bool, Text)]
    everythingIsConsistent =
        [ ( realRichBalance + realPoorBalance <= testBalance
          , "Real rich + poor balance is more than desired."
          )
        , ( oneRichmanBalance >= mpcBalance
          , "Richman's balance is less than MPC threshold"
          )
        , ( onePoorBalance < mpcBalance
          , "Poor's balance is more than MPC threshold"
          )
        ]

    checkConsistency :: a -> a
    checkConsistency = case verifyGeneric everythingIsConsistent of
        VerSuccess        -> identity
        VerFailure errors -> error $ formatAllErrors errors

    getShare :: Double -> Integer -> Integer
    getShare sh n = round $ sh * fromInteger n
