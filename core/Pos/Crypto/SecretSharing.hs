{-| An implementation of VSS (wrapping over pvss).
    For more details see <https://github.com/input-output-hk/pvss-haskell>.
-}


module Pos.Crypto.SecretSharing
       ( -- * Keys and related.
         VssPublicKey (..)
       , VssKeyPair (..)
       , toVssPublicKey
       , vssKeyGen
       , deterministicVssKeyGen

         -- * Sharing
       , DhSecret (..)
       , ShareId
       , EncShare (..)
       , Secret (..)
       , SecretProof (..)
       , SecretSharingExtra (..)
       , Share (..)
       , Threshold

       , shareId
       , encShareId
       , decryptShare
       , getDhSecret
       , genSharedSecret
       , getValidShares
       , recoverSecret
       , secretToDhSecret
       , unsafeRecoverSecret
       , verifyEncShare
       , verifySecretProof
       , verifyShare
       ) where

import           Crypto.PVSS         (Commitment, DecryptedShare, DhSecret (..),
                                      EncryptedShare, ExtraGen, KeyPair (..), Proof,
                                      ShareId, Threshold)
import qualified Crypto.PVSS         as Pvss
import           Crypto.Random       (MonadRandom)
import           Data.Hashable       (Hashable (hashWithSalt))
import           Data.List           (genericLength)
import           Data.Text.Buildable (Buildable)
import qualified Data.Text.Buildable as Buildable
import           Formatting          (bprint, (%))
import           Universum

import           Pos.Binary.Class    (Bi, serialize')
import           Pos.Crypto.Hashing  (hash, shortHashF)
import           Pos.Crypto.Random   (deterministic, runSecureRandom)

----------------------------------------------------------------------------
-- Keys
----------------------------------------------------------------------------

-- | This key is used as public key in VSS.
newtype VssPublicKey = VssPublicKey
    { getVssPublicKey :: Pvss.PublicKey
    } deriving (Show, Eq)

-- | This key pair is used to decrypt share generated by VSS.
newtype VssKeyPair =
    VssKeyPair KeyPair
    deriving (Show, Eq, Generic)

instance (Bi VssKeyPair) => Buildable VssKeyPair where
    build = bprint ("vsssec:"%shortHashF) . hash

-- | Extract VssPublicKey from VssKeyPair.
toVssPublicKey :: VssKeyPair -> VssPublicKey
toVssPublicKey (VssKeyPair pair) = VssPublicKey $ Pvss.toPublicKey pair

-- | Generate VssKeyPair using Really Secureâ„¢ randomness.
vssKeyGen :: MonadIO m => m VssKeyPair
vssKeyGen = VssKeyPair <$> liftIO (runSecureRandom Pvss.keyPairGenerate)

-- | Generate VssKeyPair using given seed.
deterministicVssKeyGen :: ByteString -> VssKeyPair
deterministicVssKeyGen seed =
    VssKeyPair $ deterministic seed Pvss.keyPairGenerate

----------------------------------------------------------------------------
-- Types
----------------------------------------------------------------------------

-- | Secret can be generated by 'genSharedSecret' function along with shares.
newtype Secret = Secret
    { getSecret :: Pvss.Secret
    } deriving (Show, Eq)

-- | Shares can be used to reconstruct 'Secret'.
newtype Share = Share
    { getShare :: DecryptedShare
    } deriving (Show, Eq)

-- | Encrypted share which needs to be decrypted using 'VssKeyPair' first.
newtype EncShare = EncShare
    { getEncShare :: EncryptedShare
    } deriving (Show, Eq)

-- | This extra data may be used to verify encrypted share.
data SecretSharingExtra =
    SecretSharingExtra !ExtraGen
                       ![Commitment]
    deriving (Show, Eq, Generic)

-- | SecretProof may be used to commit 'Secret' without revealing it.
newtype SecretProof =
    SecretProof Proof
    deriving (Show, Eq, Generic)

instance Bi SecretProof =>
         Hashable SecretProof where
    hashWithSalt s = hashWithSalt s . serialize'

----------------------------------------------------------------------------
-- Functions
----------------------------------------------------------------------------

-- | Extract ByteString from DhSecret.
getDhSecret :: DhSecret -> ByteString
getDhSecret (DhSecret s) = s

-- | Returns id of 'Share'.
shareId :: Share -> ShareId
shareId = Pvss.decryptedShareID . getShare

-- | Returns id of encrypted share.
encShareId :: EncShare -> ShareId
encShareId = Pvss.shareID . getEncShare

-- | Transform a Secret into a usable random value.
secretToDhSecret :: Secret -> DhSecret
secretToDhSecret = Pvss.secretToDhSecret . getSecret

-- | Decrypt share using secret key. Doesn't verify if an encrypted
-- share is valid, for this you need to use verifyEncShare.
decryptShare
    :: MonadRandom m
    => VssKeyPair -> EncShare -> m Share
decryptShare (VssKeyPair k) (EncShare encShare) =
    Share <$> Pvss.shareDecrypt k encShare

-- | Generate random secret using MonadRandom and share it between
-- given public keys.
genSharedSecret
    :: MonadRandom m
    => Threshold
    -> NonEmpty VssPublicKey
    -> m (SecretSharingExtra, Secret, SecretProof, [EncShare])
genSharedSecret t = fmap convertRes . Pvss.escrow t . map getVssPublicKey . toList
  where
    convertRes (g, s, p, c, es) =
        (SecretSharingExtra g c, Secret s, SecretProof p, map EncShare es)

-- | Recover secret if there are enough correct shares.
recoverSecret :: Threshold -> [(EncShare, VssPublicKey, Share)] -> Maybe Secret
recoverSecret t = recoverSecretDo t . getValidShares t

recoverSecretDo :: Threshold -> [Share] -> Maybe Secret
recoverSecretDo t shares
    | genericLength shares >= t = Just (unsafeRecoverSecret shares)
    | otherwise = Nothing

-- | Recover Secret from shares. Assumes that number of shares is
-- enough to do it. Consider using `getValidShares` first or
-- use `recoverSecret`
unsafeRecoverSecret :: [Share] -> Secret
unsafeRecoverSecret = Secret . Pvss.recover . map getShare

-- | Get #Threshold decrypted shares from given list, or less if there
-- is not enough.
getValidShares :: Threshold -> [(EncShare, VssPublicKey, Share)] -> [Share]
getValidShares t = map Share . Pvss.getValidRecoveryShares t . map convert
  where
    convert (EncShare es, VssPublicKey p, Share s) = (es, p, s)

-- CHECK: @verifyEncShare
-- | Verify an encrypted share using SecretSharingExtra.
verifyEncShare :: SecretSharingExtra -> VssPublicKey -> EncShare -> Bool
verifyEncShare (SecretSharingExtra e c) (VssPublicKey pk) (EncShare es) =
    Pvss.verifyEncryptedShare e c (es, pk)

-- CHECK: @verifyShare
-- | Verify that Share has been decrypted correctly.
verifyShare :: EncShare -> VssPublicKey -> Share -> Bool
verifyShare (EncShare es) (VssPublicKey pk) (Share sh) =
    Pvss.verifyDecryptedShare (es, pk, sh)

-- CHECK: @verifySecretProof
-- | Verify that SecretProof corresponds to Secret.
verifySecretProof :: SecretSharingExtra -> Secret -> SecretProof -> Bool
verifySecretProof (SecretSharingExtra e c) (Secret s) (SecretProof p) =
    Pvss.verifySecret e c s p
