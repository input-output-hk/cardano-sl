{-# LANGUAGE TypeFamilies #-}

-- | Core types of GodTossing SSC.

module Pos.Ssc.GodTossing.Core.Types
       (
         -- * Commitments
         Commitment (..)
       , getCommShares
       , CommitmentSignature
       , SignedCommitment
       , CommitmentsMap (getCommitmentsMap)
       , mkCommitmentsMap
       , mkCommitmentsMapUnsafe

       -- * Openings
       , Opening (..)
       , OpeningsMap

         -- * Shares
       , InnerSharesMap
       , SharesMap
       , SharesDistribution

         -- * Vss certificates
       , VssCertificate (vcVssKey, vcExpiryEpoch, vcSignature, vcSigningKey)
       , mkVssCertificate
       , recreateVssCertificate
       , getCertId
       , VssCertificatesMap(..)
       , mkVssCertificatesMap
       , memberVss
       , lookupVss
       , insertVss
       , deleteVss

       -- * Payload
       , GtPayload (..)
       , GtProof (..)

         -- * Misc
       , NodeSet
       ) where

import           Control.Lens        (each, traverseOf)
import           Data.Hashable       (Hashable (..))
import           Data.HashMap.Strict (HashMap)
import qualified Data.HashMap.Strict as HM
import qualified Data.Text.Buildable
import           Formatting          (bprint, build, int, (%))
import           Universum

import           Pos.Binary.Class    (AsBinary (..), fromBinaryM, serialize')
import           Pos.Binary.Core     ()
import           Pos.Core.Address    (addressHash)
import           Pos.Core.Types      (EpochIndex, StakeholderId)
import           Pos.Crypto          (DecShare, EncShare, Hash, PublicKey, Secret,
                                      SecretKey, SecretProof, SignTag (SignVssCert),
                                      Signature, VssPublicKey, checkSig, sign, toPublic)

type NodeSet = HashSet StakeholderId

----------------------------------------------------------------------------
-- Commitments
----------------------------------------------------------------------------

-- | Commitment is a message generated during the first stage of GodTossing.
-- It contains encrypted shares and proof of secret.
--
-- There can be more than one share generated for a single participant.
data Commitment = Commitment
    { commProof  :: !SecretProof
    , commShares :: !(HashMap (AsBinary VssPublicKey)
                              (NonEmpty (AsBinary EncShare)))
    } deriving (Show, Eq, Generic)

instance NFData Commitment
instance Hashable Commitment

-- | Get commitment shares.
getCommShares :: Commitment -> Maybe [(VssPublicKey, NonEmpty EncShare)]
getCommShares =
    traverseOf (each . _1) fromBinaryM <=<          -- decode keys
    traverseOf (each . _2 . each) fromBinaryM .     -- decode shares
    HM.toList . commShares

instance Ord Commitment where
    compare = comparing (serialize' . commProof) <>
              comparing (sort . HM.toList . commShares)

-- | Signature which ensures that commitment was generated by node
-- with given public key for given epoch.
type CommitmentSignature = Signature (EpochIndex, Commitment)

type SignedCommitment = (PublicKey, Commitment, CommitmentSignature)

-- | 'CommitmentsMap' is a wrapper for 'HashMap StakeholderId SignedCommitment'
-- which ensures that keys are consistent with values, i. e. 'PublicKey'
-- from 'SignedCommitment' corresponds to key which is 'StakeholderId'.
newtype CommitmentsMap = CommitmentsMap
    { getCommitmentsMap :: HashMap StakeholderId SignedCommitment
    } deriving (Generic, Semigroup, Monoid, Show, Eq, Container, NFData)

type instance Element CommitmentsMap = SignedCommitment

-- | Safe constructor of 'CommitmentsMap'.
mkCommitmentsMap :: [SignedCommitment] -> CommitmentsMap
mkCommitmentsMap = CommitmentsMap . HM.fromList . map toCommPair
  where
    toCommPair signedComm@(pk, _, _) = (addressHash pk, signedComm)

-- | Unsafe straightforward constructor of 'CommitmentsMap'.
mkCommitmentsMapUnsafe :: HashMap StakeholderId SignedCommitment
                       -> CommitmentsMap
mkCommitmentsMapUnsafe = CommitmentsMap

----------------------------------------------------------------------------
-- Openings
----------------------------------------------------------------------------

-- | Opening reveals secret.
newtype Opening = Opening
    { getOpening :: (AsBinary Secret)
    } deriving (Show, Eq, Generic, Buildable, NFData)

type OpeningsMap = HashMap StakeholderId Opening

----------------------------------------------------------------------------
-- Shares
----------------------------------------------------------------------------

-- | Each node generates several 'SharedSeed's, breaks every
-- 'SharedSeed' into 'Share's, and sends those encrypted shares to
-- other nodes (for i-th commitment at i-th element of NonEmpty
-- list). Then those shares are decrypted.
type InnerSharesMap = HashMap StakeholderId (NonEmpty (AsBinary DecShare))

-- | In a 'SharesMap', for each node we collect shares which said node
-- has received and decrypted:
--
--   * Outer key = who decrypted the share
--   * Inner key = who created the share
--
-- Let's say that there are participants {A, B, C}. If A has generated a
-- secret and shared it, A's shares will be denoted as Ab and Ac (sent
-- correspondingly to B and C). Then node B will decrypt the share and get
-- Ab_dec; same for other nodes and participants. In the end, after the
-- second phase of the protocol completes and we gather everyone's shares,
-- we'll get the following map:
--
-- @
-- { A: {B: Ba_dec, C: Ca_dec}
-- , B: {A: Ab_dec, C: Cb_dec}
-- , C: {A: Ac_dec, B: Bc_dec}
-- }
-- @
--
-- (Here there's only one share per node, but in reality there'll be more.)
type SharesMap = HashMap StakeholderId InnerSharesMap

-- | This maps shareholders to amount of shares she should issue. Depends on
-- the stake distribution.
type SharesDistribution = HashMap StakeholderId Word16

instance Buildable (StakeholderId, Word16) where
    build (id, c) = bprint ("("%build%": "%build%" shares)") id c

----------------------------------------------------------------------------
-- Vss certificates
----------------------------------------------------------------------------

-- | VssCertificate allows VssPublicKey to participate in MPC. Each
-- stakeholder should create a Vss keypair, sign VSS public key with signing
-- key and send it into blockchain.
--
-- A public key of node is included in certificate in order to enable
-- validation of it using only node's P2PKH address. Expiry epoch is last
-- epoch when certificate is valid, expiry epoch is included in certificate
-- and signature.
--
-- Other nodes accept this certificate if it is valid and if node has enough
-- stake.
--
-- Invariant: 'checkSig vcSigningKey (vcVssKey, vcExpiryEpoch) vcSignature'.
data VssCertificate = VssCertificate
    { vcVssKey      :: !(AsBinary VssPublicKey)
    , vcExpiryEpoch :: !EpochIndex
    -- ^ Epoch up to which certificates is valid.
    , vcSignature   :: !(Signature (AsBinary VssPublicKey, EpochIndex))
    , vcSigningKey  :: !PublicKey
    } deriving (Show, Eq, Generic)

instance NFData VssCertificate

instance Ord VssCertificate where
    compare a b = toTuple a `compare` toTuple b
      where
        toTuple VssCertificate {..} =
            (vcExpiryEpoch, vcVssKey, vcSigningKey, vcSignature)

instance Buildable VssCertificate where
    build VssCertificate {..} = bprint
        ("vssCert:"%build%":"%int) vcSigningKey vcExpiryEpoch

instance Hashable VssCertificate where
    hashWithSalt s VssCertificate{..} =
        hashWithSalt s (vcExpiryEpoch, vcVssKey, vcSigningKey, vcSignature)

-- | Make VssCertificate valid up to given epoch using 'SecretKey' to sign
-- data.
mkVssCertificate :: SecretKey -> AsBinary VssPublicKey -> EpochIndex -> VssCertificate
mkVssCertificate sk vk expiry =
    VssCertificate vk expiry signature (toPublic sk)
  where
    signature = sign SignVssCert sk (vk, expiry)

-- | Recreate 'VssCertificate' from its contents. This function main
-- 'fail' if data is invalid.
recreateVssCertificate
    :: MonadFail m
    => AsBinary VssPublicKey
    -> EpochIndex
    -> Signature (AsBinary VssPublicKey, EpochIndex)
    -> PublicKey
    -> m VssCertificate
recreateVssCertificate vssKey epoch sig pk =
    res <$
    (unless (checkCertSign res) $ fail "recreateVssCertificate: invalid sign")
  where
    res =
        VssCertificate
        { vcVssKey = vssKey
        , vcExpiryEpoch = epoch
        , vcSignature = sig
        , vcSigningKey = pk
        }

-- CHECK: @checkCertSign
-- | Check that the VSS certificate is signed properly
-- #checkPubKeyAddress
-- #checkSig
checkCertSign :: VssCertificate -> Bool
checkCertSign VssCertificate {..} =
    checkSig SignVssCert vcSigningKey (vcVssKey, vcExpiryEpoch) vcSignature

getCertId :: VssCertificate -> StakeholderId
getCertId = addressHash . vcSigningKey

-- | VssCertificatesMap contains all valid certificates collected
-- during some period of time.
--
-- Invariants:
--   * stakeholder ids correspond to 'vcSigningKey's of associated certs
--   * no two certs have the same 'vcVssKey'
newtype VssCertificatesMap = VssCertificatesMap
    { getVssCertificatesMap :: HashMap StakeholderId VssCertificate }
    deriving (Eq, Show, Generic, NFData, Monoid, Container, NontrivialContainer)

type instance Element VssCertificatesMap = VssCertificate

memberVss :: StakeholderId -> VssCertificatesMap -> Bool
memberVss id (VssCertificatesMap m) = HM.member id m

lookupVss :: StakeholderId -> VssCertificatesMap -> Maybe VssCertificate
lookupVss id (VssCertificatesMap m) = HM.lookup id m

insertVss :: VssCertificate -> VssCertificatesMap -> VssCertificatesMap
insertVss c (VssCertificatesMap m) =
    VssCertificatesMap (HM.insert (getCertId c) c m)

deleteVss :: StakeholderId -> VssCertificatesMap -> VssCertificatesMap
deleteVss id (VssCertificatesMap m) = VssCertificatesMap (HM.delete id m)

-- | Safe constructor of 'VssCertificatesMap'.
--
-- (Well, almost safe: it doesn't check that all certificates have different
-- 'vcVssKey's).
mkVssCertificatesMap :: [VssCertificate] -> VssCertificatesMap
mkVssCertificatesMap = VssCertificatesMap . HM.fromList . map toCertPair
  where
    toCertPair vc = (getCertId vc, vc)

----------------------------------------------------------------------------
-- Payload and proof
----------------------------------------------------------------------------

-- | Payload included into blocks.
data GtPayload
    = CommitmentsPayload
        { gpComms :: !CommitmentsMap
        , gpVss   :: !VssCertificatesMap }
    | OpeningsPayload
        { gpOpenings :: !OpeningsMap
        , gpVss      :: !VssCertificatesMap }
    | SharesPayload
        { gpShares :: !SharesMap
        , gpVss    :: !VssCertificatesMap }
    | CertificatesPayload
        { gpVss    :: !VssCertificatesMap }
    deriving (Eq, Show, Generic)

-- | Proof of GtPayload.
data GtProof
    = CommitmentsProof
        { gprComms :: !(Hash CommitmentsMap)
        , gprVss   :: !(Hash VssCertificatesMap) }
    | OpeningsProof
        { gprOpenings :: !(Hash OpeningsMap)
        , gprVss      :: !(Hash VssCertificatesMap) }
    | SharesProof
        { gprShares :: !(Hash SharesMap)
        , gprVss    :: !(Hash VssCertificatesMap) }
    | CertificatesProof
        { gprVss    :: !(Hash VssCertificatesMap) }
    deriving (Show, Eq, Generic)

instance NFData GtPayload
instance NFData GtProof
