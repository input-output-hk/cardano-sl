{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE Rank2Types     #-}

-- | VSS certificates and secrets related stuff.

module Pos.Client.CLI.Secrets
       ( prepareUserSecret
       ) where

import           Universum

import           Control.Lens (ix)
import           Crypto.Random (MonadRandom)

import           Pos.Core (HasConfiguration, genesisSecretsRich)
import           Pos.Core.Genesis (RichSecrets (..))
import           Pos.Crypto (SecretKey, VssKeyPair, keyGen, runSecureRandom,
                     vssKeyGen)
import           Pos.Util.UserSecret (UserSecret, usPrimKey, usVss,
                     writeUserSecret)

import           Pos.Client.CLI.NodeOptions (CommonNodeArgs (..))
import           Pos.Util.Trace.Named (TraceNamed, logInfo)

-- | This function prepares 'UserSecret' for later usage by node. It
-- ensures that primary key and VSS key are present in
-- 'UserSecret'. They are either taken from generated secrets or
-- generated by this function using secure source of randomness.
prepareUserSecret ::
       forall m. (HasConfiguration, MonadIO m)
    => TraceNamed m
    -> CommonNodeArgs
    -> UserSecret
    -> m (SecretKey, UserSecret)
prepareUserSecret logTrace CommonNodeArgs {devGenesisSecretI} userSecret = do
    (_, userSecretWithVss) <-
        fillUserSecretVSS logTrace (rsVssKeyPair <$> predefinedRichKeys) userSecret
    fillPrimaryKey logTrace (rsPrimaryKey <$> predefinedRichKeys) userSecretWithVss
  where
    onUnknownGeneratedSecrets =
        error $
        "devGenesisSecretI is specified, but no generatedSecrets is present.\n" <>
        "Try to change initializer in genesis spec"
    predefinedRichKeys :: Maybe RichSecrets
    predefinedRichKeys
        | Just secretsRich <- genesisSecretsRich
        , Just i <- devGenesisSecretI = secretsRich ^? ix i
        | Nothing <- devGenesisSecretI = Nothing
        | otherwise = onUnknownGeneratedSecrets

-- Make sure UserSecret contains a primary key.
fillPrimaryKey ::
       MonadIO m
    => TraceNamed m
    -> Maybe SecretKey
    -> UserSecret
    -> m (SecretKey, UserSecret)
fillPrimaryKey logTrace = fillUserSecretPart logTrace (snd <$> keyGen) usPrimKey "signing key"

-- Make sure UserSecret contains a VSS key.
fillUserSecretVSS ::
       MonadIO m
    => TraceNamed m
    -> Maybe VssKeyPair
    -> UserSecret
    -> m (VssKeyPair, UserSecret)
fillUserSecretVSS logTrace = fillUserSecretPart logTrace vssKeyGen usVss "VSS keypair"

-- Make sure UserSecret contains something.
fillUserSecretPart
    :: MonadIO m
    => TraceNamed m
    -> (forall n. MonadRandom n =>
                      n a)
    -> (Lens' UserSecret (Maybe a))
    -> Text
    -> Maybe a
    -> UserSecret
    -> m (a, UserSecret)
fillUserSecretPart logTrace genValue l description desiredValue userSecret = do
    toSet <- getValueToSet
    let newUS = userSecret & l .~ Just toSet
    (toSet, newUS) <$ writeUserSecret newUS
  where
    getValueToSet
        | Just desired <- desiredValue = pure desired
        | Just existing <- userSecret ^. l = pure existing
        | otherwise = do
            logInfo logTrace $
                "Found no " <> description <>
                " in keyfile, generating random one..."
            liftIO (runSecureRandom genValue)
