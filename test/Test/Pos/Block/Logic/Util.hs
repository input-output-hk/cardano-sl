-- | Utilities for block logic testing.

module Test.Pos.Block.Logic.Util
       ( bpGenBlocks
       , bpGoToArbitraryState
       , withCurrentSlot
       , satisfySlotCheck
       ) where

import           Universum

import           Test.QuickCheck.Gen       (sized)
import           Test.QuickCheck.Monadic   (pick)
import           Test.QuickCheck.Random    (newQCGen)

import           Pos.Block.Core            (Block)
import           Pos.Block.Types           (Blund)
import           Pos.Core                  (BlockCount, SlotId (..), epochIndexL)
import           Pos.Generator.Block       (BlockGenParams (..), genBlocks)
import           Pos.Ssc.GodTossing        (SscGodTossing)
import           Pos.Util.Chrono           (NE, OldestFirst (..))
import           Pos.Util.Util             (HasLens (..), _neLast)

import           Test.Pos.Block.Logic.Mode (BlockProperty, BlockTestContext,
                                            BlockTestContextTag, btcSlotId_L,
                                            tpAllSecrets)

-- | Generate arbitrary valid blocks inside 'BlockProperty'. The first
-- argument specifies how many blocks should be generated. If it's
-- 'Nothing', the number of blocks will be generated by QuickCheck
-- engine.
bpGenBlocks :: Maybe BlockCount -> BlockProperty (OldestFirst [] (Blund SscGodTossing))
bpGenBlocks blkCnt = do
    allSecrets <- lift $ view (lensOf @BlockTestContextTag . tpAllSecrets)
    let genBlockGenParams s =
            pure
                BlockGenParams
                { _bgpSecrets = allSecrets
                , _bgpBlockCount = fromMaybe (fromIntegral s) blkCnt
                }
    params <- pick $ sized genBlockGenParams
    g <- liftIO newQCGen
    lift (genBlocks params g)

-- | Go to arbitrary global state in 'BlockProperty'.
bpGoToArbitraryState :: BlockProperty ()
-- TODO: generate arbitrary blocks, apply them.
bpGoToArbitraryState = pass

-- | Perform action pretending current slot is the given one.
withCurrentSlot :: MonadReader BlockTestContext m => SlotId -> m a -> m a
withCurrentSlot slot = local (set btcSlotId_L $ Just slot)

-- | This simple helper is useful when one needs to verify
-- blocks. Blocks verification checks that blocks are not from
-- future. This function pretends that current slot is after the last
-- slot of the given blocks.
satisfySlotCheck ::
       MonadReader BlockTestContext m
    => OldestFirst NE (Block SscGodTossing)
    -> m a
    -> m a
satisfySlotCheck (OldestFirst blocks) action =
    let lastEpoch = blocks ^. _neLast . epochIndexL
    in withCurrentSlot (SlotId (lastEpoch + 1) minBound) action
